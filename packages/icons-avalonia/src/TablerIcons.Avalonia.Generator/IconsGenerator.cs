using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml.Linq;

namespace TablerIcons.Avalonia.Generator
{
    [Generator]
    internal class IconsGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
        }

        public void Execute(GeneratorExecutionContext context)
        {
            var source = GetSource(context);
            if (source is null)
                return;
            
            context.AddSource("TablerIcons.Avalonia.Icons.g.cs", source);
        
        }

        private int _fileCount = 0;
        private string? _source;
        
        public string? GetSource(GeneratorExecutionContext context)
        {
            if (_source is not null && _fileCount == context.AdditionalFiles.Length)
                return _source;

            var enumLines = new List<string>();
            var switchLines = new StringBuilder();

            const string isvgDataType = "global::TablerIcons.Avalonia.ISvgData";

            const string enumType = "global::TablerIcons.Avalonia.Icons";

            foreach (var file in context.AdditionalFiles)
            {
                var isIcon = GetIsIcon(file);
                if (!isIcon)
                    continue;

                var content = file.GetText()?.ToString();
                if (content == null)
                    continue;

                var name = Path.GetFileNameWithoutExtension(file.Path);
                var filled = name.EndsWith("-filled");

                var fn = GetSvgPaths(
                    name,
                    content ?? "",
                    filled);

                if (fn is null)
                    continue;

                var f = fn.Value;

                var pathData = string.Join(", ", f.data);

                var pascalName = Regex.Replace(
                    f.name?.ToLower() ?? "",
                    "(^|[_-])(.)",
                    x => x.Groups[2].Value.ToUpper());

                pascalName = $"Icon{pascalName}";

                enumLines.Add($"\t\t{pascalName},");

                switchLines.AppendLine(
                    $"\t\t\t\tcase {enumType}.{pascalName}:\n\t\t\t\t\t return new {isvgDataType}[] {{ {pathData} }};");
            }

            var source = $@"// <auto-generated/>
namespace TablerIcons.Avalonia 
{{
    [global::System.CodeDom.Compiler.GeneratedCode(""TablerIcons.Avalonia.Generator"", ""1.0.0"")]
    public enum Icons
    {{
{string.Join("\n", enumLines.OrderBy(x => x))}
    }}

    [global::System.CodeDom.Compiler.GeneratedCode(""TablerIcons.Avalonia.Generator"", ""1.0.0"")]
    internal static class IconsExtension 
    {{
        public static {isvgDataType}[] GetPathData(this {enumType} icon)
        {{
            switch (icon)
            {{
{switchLines}
                default:
                    return new {isvgDataType}[] {{}};
            }}
        }}
    }}
}}
            ";

            _source = source;
            _fileCount = context.AdditionalFiles.Length;

            return source;
        }

        private bool GetIsIcon(AdditionalText file)
        {
            var iconsDir = Path.GetDirectoryName(file.Path).EndsWith("icons");
            var isIconsFile = file.Path.EndsWith(".svg");
            return iconsDir && isIconsFile;
        }

        private (string name, bool filled, IEnumerable<string> data)?
            GetSvgPaths(string name, string content, bool filled)
        {

            var c = XElement.Parse(content);

            if (name is null || c is null)
                return null;

            var mainFill = c.Attribute("fill")?.Value;
            var mainStroke = c.Attribute("stroke")?.Value;

            if (mainFill is null || mainStroke is null)
                return null;

            var svgPaths = c.Descendants()
                .Where(x => 
                    (x.Attribute("stroke")?.Value ?? "") != "none" &&
                    (x.Attribute("fill")?.Value ?? "") != "none");

            if (!svgPaths.Any())
                return null;

            var isStroke = (!filled).ToString().ToLower();

            var svgPathsResults = svgPaths.Select(x =>
                x.Name.LocalName switch
                {
                    "path" => GetPathData(x, isStroke),
                    "rect" => GetRectData(x, isStroke),
                    "circle" => GetCircleData(x, isStroke),
                    "g" => GetDefaultStrokeWidthData(x),
                    _ => "",
                });

            return (name, filled, svgPathsResults);
        }

        private string GetPathData(XElement element, string isStroke)
        {
            const string pathDataType = "global::TablerIcons.Avalonia.PathData";
            var isFill = element.Attribute("fill")?.Value is not null ? "true" : "false";

            var data = element.Attribute("d")?.Value ?? "";
            return $"new {pathDataType}(\"{data}\", {isStroke}, {isFill})";
        }

        private string GetRectData(XElement element, string isStroke)
        {
            const string rectDataType = "global::TablerIcons.Avalonia.RectData";

            var x = element.Attribute("x")?.Value ?? "0";
            var y = element.Attribute("y")?.Value ?? "0";
            var width = element.Attribute("width")?.Value ?? "0";
            var height = element.Attribute("height")?.Value ?? "0";
            var rx = element.Attribute("rx")?.Value ?? "0";
            var isFill = element.Attribute("fill")?.Value is not null ? "true" : "false";

            return $"new {rectDataType}(0{x}f, 0{y}f, 0{width}f, 0{height}f, 0{rx}f, {isStroke}, {isFill})";
        }

        private string GetCircleData(XElement element, string isStroke)
        {
            const string circDataType = "global::TablerIcons.Avalonia.CircleData";

            var cx = element.Attribute("cx")?.Value ?? "0";
            var cy = element.Attribute("cy")?.Value ?? "0";
            var r = element.Attribute("r")?.Value ?? "0";
            var isFill = element.Attribute("fill")?.Value is not null ? "true" : "false";

            return $"new {circDataType}(0{cx}f, 0{cy}f, 0{r}f, {isStroke}, {isFill})";
        }

        private string GetDefaultStrokeWidthData(XElement x)
        {
            const string defDataType = "global::TablerIcons.Avalonia.DefaultStrokeWidthData";
            var strokeWidth = x.Attribute("stroke-width")?.Value ?? "2";
            return $"new {defDataType}(0{strokeWidth}f)";
        }
    }
}
