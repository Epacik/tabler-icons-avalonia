using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.RegularExpressions;
using System.Threading;
using System.Xml.Linq;

namespace TablerIcons.Avalonia.Generator
{
    [Generator]
    internal class IconsGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
        }

        public void Execute(GeneratorExecutionContext context)
        {

            var enumLines = new List<string>();
            var switchLines = new StringBuilder();

            const string pathDataType = "global::TablerIcons.Avalonia.PathData";
            const string enumType = "global::TablerIcons.Avalonia.Icons";

            foreach (var file in context.AdditionalFiles)
            {
                var isIcon = GetIsIcon(file);
                if (!isIcon)
                    continue;

                var content = file.GetText()?.ToString();
                if (content == null)
                    return;

                var name = Path.GetFileNameWithoutExtension(file.Path);
                var filled = name.EndsWith("-filled");

                var fn = GetSvgPaths(name, file.GetText()?.ToString() ?? "", filled);

                if (fn is null)
                    continue;

                var f = fn.Value;

                var pathDataList = f.data.Select(x => $"new {pathDataType}(\"{x.path}\", \"{x.fill}\", \"{x.stroke}\")");

                var pathData = string.Join(", ", pathDataList);

                var pascalName = Regex.Replace(
                    f.name?.ToLower() ?? "",
                    "(^|[_-])(.)",
                    x => x.Groups[2].Value.ToUpper());

                pascalName = $"Icon{pascalName}";

                enumLines.Add($"\t\t{pascalName},");

                switchLines.AppendLine(
                    $"\t\t\t\tcase {enumType}.{pascalName}:\n\t\t\t\t\t return new {pathDataType}[] {{ {pathData} }};");
            }

            var source = $@"// <auto-generated/>
namespace TablerIcons.Avalonia 
{{
    [global::System.CodeDom.Compiler.GeneratedCode(""TablerIcons.Avalonia.Generator"", ""1.0.0"")]
    public enum Icons
    {{
{string.Join("\n", enumLines.OrderBy(x => x))}
    }}

    [global::System.CodeDom.Compiler.GeneratedCode(""TablerIcons.Avalonia.Generator"", ""1.0.0"")]
    internal static class IconsExtension 
    {{
        public static global::System.Collections.Generic.IEnumerable<{pathDataType}> GetPathData(this {enumType} icon)
        {{
            switch (icon)
            {{
{switchLines}
                default:
                    return new global::TablerIcons.Avalonia.PathData[] {{}};
            }}
        }}
    }}
}}
            ";
            context.AddSource("TablerIcons.Avalonia.Icons.g.cs", source);
        
        }

        private bool GetIsIcon(AdditionalText file)
        {
            var iconsDir = Path.GetDirectoryName(file.Path).EndsWith("icons");
            var isIconsFile = file.Path.EndsWith("tabler-nodes.json");
            return iconsDir && isIconsFile;
        }

        private (string name, bool filled, IEnumerable<(string path, string fill, string stroke)> data)?
            GetSvgPaths(string name, string content, bool filled)
        {

            var c = XElement.Parse(content);

            if (name is null || c is null)
                return null;

            var mainFill = c.Attribute("fill")?.Value;
            var mainStroke = c.Attribute("stroke")?.Value;

            if (mainFill is null || mainStroke is null)
                return null;

            var svgPaths = c
                .Descendants()
                .Where(x => x.Name.LocalName == "path");

            if (!svgPaths.Any())
                return null;

            var svgPathsResults = svgPaths.Select(x =>
                (
                    x.Attribute("d")?.Value ?? "",
                    x.Attribute("fill")?.Value ?? mainFill,
                    x.Attribute("stroke")?.Value ?? mainStroke
                ));

            return (name, filled, svgPathsResults);
        }
    }

}
